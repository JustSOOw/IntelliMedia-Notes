# IntelliMedia Notes - AI增强多媒体笔记应用

IntelliMedia Notes是一款功能丰富的笔记应用程序，融合了现代界面设计与AI辅助功能，为用户提供流畅的笔记编辑与管理体验。应用采用无边框设计，支持深色/浅色主题，通过Qt混合技术（Widgets与QML）构建了精美的用户界面。

## 核心功能

- **现代化无边框界面**：采用无边框窗口设计，支持窗口拖动、调整大小、最大化/最小化
- **深色/浅色主题切换**：整合全局主题系统，适配所有组件和界面元素
- **文件管理系统**：树形结构的笔记与文件夹管理，支持创建、重命名、删除操作
- **富文本编辑**：强大的文本编辑功能，支持格式化、对齐、颜色调整、高亮等多种格式化操作
- **浮动工具栏**：智能的文本选择浮动工具栏，提供便捷的格式化功能
- **全局搜索**：快速搜索笔记内容，支持多种排序方式（最近修改、创建时间、名称）
- **AI助手集成**：内置AI对话功能，辅助笔记创作与信息查询
- **文件操作**：右键菜单支持便捷的文件与文件夹操作
- **用户面板**：显示用户信息与状态
- **个性化设置**：提供主题、语言、自动保存等多种个性化设置选项
- **国际化支持**：支持中文和英文界面，可根据系统或用户设置自动切换语言

## 界面组成

应用界面由以下主要部分组成：

1. **标题栏**：包含侧边栏切换按钮、主题切换、设置按钮、窗口控制按钮（最小化/最大化/关闭）
2. **侧边栏**：使用QML实现的侧边栏，包含用户面板、搜索入口、文件树、创建按钮
3. **主内容区**：用于显示和编辑笔记内容，集成了功能强大的富文本编辑器
4. **浮动工具栏**：文本选择时自动显示的格式化工具栏，提供常用的文本格式化功能
5. **搜索弹窗**：独立的搜索界面，支持高级搜索和结果展示
6. **AI对话界面**：AI助手交互界面
7. **设置对话框**：个性化设置界面，支持主题、语言、自动保存等设置

## 技术栈

- **编程语言**：C++ (C++17)
- **UI框架**：Qt 6（混合使用Qt Widgets与Qt Quick/QML）
- **数据存储**：SQLite数据库（通过Qt SQL模块）
- **构建系统**：CMake
- **资源管理**：Qt资源系统（.qrc文件）
- **图标系统**：SVG矢量图标，支持主题颜色自适应
- **国际化**：Qt Linguist翻译系统，支持多语言界面

## 架构设计

### 模块划分

1. **主窗口管理 (MainWindow)**
   - 负责整体窗口框架、标题栏、窗口控制
   - 管理主题切换
   - 集成侧边栏与主内容区

2. **侧边栏管理 (SidebarManager)**
   - 通过QML实现侧边栏界面
   - 管理笔记树与文件夹结构
   - 处理笔记操作（创建、删除、重命名）
   - 集成用户面板

3. **文本编辑器管理 (TextEditorManager)**
   - 基于QTextEdit的富文本编辑功能
   - 浮动工具栏的管理与显示
   - 文本格式化操作（粗体、斜体、下划线、删除线等）
   - 段落对齐方式控制（左对齐、居中、右对齐、两端对齐）
   - 文本颜色和背景高亮

4. **数据库管理 (DatabaseManager)**
   - 笔记与文件夹的CRUD操作
   - 搜索功能
   - 内容块管理
   - 图片标注数据存储

5. **搜索管理 (SearchManager)**
   - 弹出式搜索界面
   - 结果展示与交互
   - 搜索过滤与排序

6. **设置管理 (SettingsDialog)**
   - 个性化设置界面
   - 主题切换设置
   - 语言设置
   - 自动保存设置
   - 背景设置

### 混合UI技术

应用采用了Qt Widgets与QML混合技术：
- **Qt Widgets**：主窗口框架、布局、对话框、富文本编辑器
- **QML/Qt Quick**：侧边栏、搜索界面、AI对话界面
- **QQuickWidget**：用于将QML组件嵌入Qt Widgets布局

### 数据流

1. C++后端管理数据模型与业务逻辑
2. 通过QML上下文属性与信号/槽机制，在C++与QML之间传递数据
3. 数据变更通过信号即时同步到界面

## QML特性应用

IntelliMedia Notes充分利用了QML的强大特性：

- **属性绑定**：实现主题颜色自动更新、动态布局
- **动画效果**：平滑的过渡动画、悬停效果、展开/折叠动画
- **样式化**：圆角、阴影、渐变背景、图标着色
- **状态与过渡**：组件状态管理（如选中、悬停状态）
- **颜色叠加**：SVG图标根据主题动态着色
- **自定义对话框**：使用QML实现美观的自定义对话框
- **滚动视图优化**：自定义滚动条样式与行为

## 主要功能模块

### 笔记管理

- **多级文件夹**：支持无限层级的文件夹结构
- **拖放操作**：支持通过拖放重新组织笔记和文件夹（计划中）
- **快速创建**：通过右键菜单或专用按钮快速创建新笔记/文件夹

### 富文本编辑

- **文本格式化**：支持粗体、斜体、下划线、删除线等基本格式
- **颜色功能**：文本颜色和背景高亮设置
- **对齐控制**：段落左对齐、居中、右对齐、两端对齐
- **浮动工具栏**：选择文本时自动显示的格式化工具栏，跟随选择位置
- **主题适配**：编辑器会根据当前主题自动调整颜色方案

### 搜索功能

- **全文检索**：搜索笔记标题和内容
- **多种排序**：支持按修改时间、创建时间、名称排序
- **美观展示**：卡片式结果展示，包含预览内容
- **实时搜索**：快速响应搜索请求

### AI助手

- **上下文对话**：支持多轮对话
- **内容分析**：针对笔记内容提供建议
- **写作辅助**：提供润色、修改、总结等功能

### 设置功能

- **主题设置**：支持浅色/深色/系统主题切换，自定义背景图片
- **语言设置**：支持简体中文/英文界面语言切换
- **自动保存**：可设置启用/禁用自动保存，并选择自动保存间隔
- **编辑器设置**：可设置默认字体、制表符宽度、自动配对括号和引号
- **AI服务设置**：可配置API密钥、服务提供商和API端点，支持连接测试
- **数据与存储设置**：可更改笔记库位置，支持备份/恢复和导入/导出功能
- **关于页面**：显示应用信息、版本、版权和致谢
- **标签式界面**：左侧标签导航，右侧设置内容
- **即时应用**：关闭设置对话框时自动保存并应用设置

## 界面风格

IntelliMedia Notes采用现代化设计理念，实现了一套完整的主题系统：

- **主题切换**：支持浅色/深色/系统主题一键切换
- **全局样式表**：使用QSS样式表为所有组件提供一致的视觉风格
- **组件适配**：所有自定义和内置组件都适配主题变化
- **实时预览**：在设置界面中可实时预览主题效果
- **主题保存**：所选主题会立即保存并应用到整个应用

## 国际化支持

IntelliMedia Notes通过Qt Linguist工具提供多语言支持：

- **多语言界面**：支持简体中文和英文界面
- **动态切换**：可在运行时切换语言，无需重启应用
- **语言设置**：可在设置对话框中选择界面语言，也可选择跟随系统设置
- **完整翻译**：所有UI元素和消息都有对应翻译
- **翻译管理**：使用标准的Qt翻译文件(.ts)和二进制翻译文件(.qm)

## 多语言支持

IntelliMedia Notes 应用支持多语言界面，目前实现了中文和英文的完整支持。主要功能包括：

- 所有界面元素的多语言文本支持，包括主窗口、侧边栏、编辑器和各种对话框
- 使用QTranslator实现动态的语言切换
- 支持跟随系统语言设置
- 完整的英文翻译文件 (intellimedia_notes_en_US.ts)

语言切换可在设置对话框的"常规"选项卡中进行，更改后需要重启应用程序以应用新的语言设置。

## 如何使用

### 编译环境需求

- C++17兼容编译器（如MSVC、GCC、Clang）
- Qt 6.x（包含Widgets、Quick、SQL、SVG、QuickControls2模块）
- CMake 3.16+

### 编译步骤

1. 克隆项目仓库
2. 在项目根目录执行：
   ```
   mkdir build
   cd build
   cmake ..
   cmake --build .
   ```
3. 运行编译生成的可执行文件

### 基本操作

- **创建笔记/文件夹**：在侧边栏右键点击或使用"+"按钮
- **搜索**：点击侧边栏顶部搜索图标
- **主题切换**：点击窗口右上角月亮/太阳图标
- **窗口操作**：标准的最小化/最大化/关闭按钮
- **修改笔记**：双击打开笔记进行编辑
- **文本格式化**：选择文本后使用浮动工具栏的按钮进行格式化
- **文件操作**：右键点击文件或文件夹，在上下文菜单中选择操作
- **语言切换**：在设置对话框中选择界面语言

## 开发计划

后续开发计划包括：
- 支持更多语言的国际化
- 支持图片嵌入与标注
- 扩展富文本编辑器功能，支持更多格式化选项
- 集成更强大的AI模型
- 云同步功能
- PDF查看与注释
- 列表和表格支持
- 多标签页界面

## 项目源码结构

- **src/**: C++源代码
  - mainwindow.cpp/h: 主窗口实现
  - sidebarmanager.cpp/h: 侧边栏管理
  - texteditormanager.cpp/h: 富文本编辑器管理
  - databasemanager.cpp/h: 数据库管理
  - searchmanager.cpp/h: 搜索功能管理
  - settingsdialog.cpp/h: 设置对话框管理
  - main.cpp: 程序入口

- **resources/qml/**: QML界面组件
  - Sidebar.qml: 侧边栏主组件
  - NoteTree.qml: 笔记树视图
  - SearchView.qml: 搜索界面
  - FileContextMenu.qml: 文件上下文菜单
  - AIView.qml: AI对话界面
  - UserPanel.qml: 用户面板
  - ActionButtons.qml: 操作按钮组

- **resources/icons/**: SVG图标
  - 主题自适应图标资源
  - editor/: 富文本编辑器图标

- **resources/styles/**: QSS样式文件
  - light_theme.qss: 亮色主题样式
  - dark_theme.qss: 暗色主题样式

- **resources/translations/**: 翻译文件
  - intellimedia_notes_en_US.ts: 英文翻译源文件
  - intellimedia_notes_en_US.qm: 编译后的英文翻译文件

- **forms/**: UI文件
  - mainwindow.ui: 主窗口UI设计

## 图片处理关键技术点 (NoteTextEdit)

为了在 `QTextEdit` 中实现行内图片的选中、移动和调整大小，特别是在图文混排的情况下，采用了以下关键技术：

1.  **基于几何区域的命中检测 (`mousePressEvent`)**: 放弃主要依赖 `cursorForPosition` 来判断点击对象。改为遍历视口内可见文本块的图片片段 (`QTextFragment`)，计算每个图片在文档坐标系中的精确矩形，并转换为视口坐标。通过检查鼠标点击的视口坐标是否落在某个图片的视口矩形内来确定选中的图片。这比依赖光标位置更精确，不易受相邻文本或格式干扰。
2.  **精确的光标定位**: 选中图片时，将 `m_selectedImageCursor`（用于追踪选中状态的光标）明确设置到图片对象字符的**起始位置**。
3.  **调整大小格式获取修正 (`updateImageSize`)**: 在调整大小时，获取当前图片格式不再使用 `m_selectedImageCursor.charFormat()`（它获取的是插入点格式），而是创建一个临时光标，向前移动选中图片字符，然后获取这个选中字符的格式 (`tempCursor.charFormat()`)。
4.  **拖放状态管理 (`mouseMoveEvent`, `dropEvent`)**:
    *   在 `mouseMoveEvent` 检测到拖动开始时，将当前选中图片的**位置**和**格式**存储在临时的成员变量 (`m_dragStartPosition`, `m_draggedImageFormat`) 中。
    *   **不**在启动拖动时删除原图或清除选中状态，避免 `QDrag::exec()` 阻塞期间状态被意外修改。
    *   在 `dropEvent` 处理内部移动时，先根据存储的 `m_dragStartPosition` 删除原始图片，然后在放置点使用存储的 `m_draggedImageFormat` 插入图片，最后清理临时变量。
5.  **事件处理顺序 (`mouseMoveEvent`)**: 调整了 `mouseMoveEvent` 的处理顺序，确保在进行手柄命中判断或拖放操作前，先调用基类事件处理并更新图片选中矩形 (`updateSelectionIndicator`)，以保证状态的同步。
6.  **显式光标更新 (`dropEvent`)**: 在 `dropEvent` 处理完内部移动并设置 `m_selectedImageCursor` 后，显式调用 `setTextCursor()` 来更新 `QTextEdit` 的主编辑光标，防止光标卡死。
7.  **手柄绘制 (`drawSelectionIndicator`)**: 手柄的绘制基于 `updateSelectionIndicator` 计算出的 `m_selectedImageRect`（图片在视口中的矩形）进行定位。
8.  **强制重绘与焦点 (`dropEvent`)**: 在内部移动图片并更新光标后，调用 `viewport()->repaint()` 和 `setFocus()` 来解决光标视觉上卡死（不显示或不闪烁）的问题。

这些措施共同解决了在图文混排时，图片选择不精确、手柄绘制混乱、拖动状态丢失、调整大小失败以及移动后光标显示异常等问题。

## 开发与维护说明

### 翻译文件更新流程 (重要)

在开发过程中发现，由于项目资源文件 (`resources/resources.qrc`) 直接嵌入了编译后的 `.qm` 文件 (`resources/translations/intellimedia_notes_en_US.qm`)，标准的 `lrelease` 工具在构建目录 (`build/`) 中生成的 `.qm` 文件并未被实际使用，导致即使修改了 `.ts` 文件并重新构建，部分界面的翻译也无法更新。

**解决方案：**
在修改了 `.ts` 文件 (例如 `resources/translations/intellimedia_notes_en_US.ts`) 之后，需要**手动运行 `lrelease` 命令**将最新的翻译直接生成到源文件目录下，**然后再进行项目构建** (`cmake --build build`)。

**更新翻译所需命令 (在项目根目录运行):**

```powershell
lrelease resources/translations/intellimedia_notes_en_US.ts -qm resources/translations/intellimedia_notes_en_US.qm
```

运行此命令后再执行 `cmake --build build` 或在 IDE 中重新构建，即可确保最新的翻译被嵌入到应用程序中。

## QML布局问题排查与解决案例：ActionButtons组件

在开发"启动时最小化到系统托盘"功能时，`ActionButtons.qml` 组件（位于侧边栏，包含文件、AI、搜索三个切换按钮）在从系统托盘恢复窗口后，出现了按钮布局错乱的问题。具体表现为按钮重叠或间距不均，而正常启动或不使用托盘功能时布局可能正常。

### 问题现象的演进与原因分析

1.  **初始问题**：从托盘恢复后，`ActionButtons.qml` 内的 `RowLayout`（`buttonRowLayout`）未能正确均分宽度给其子按钮，导致按钮挤压或间距异常。
2.  **深层原因分析**：
    *   **时序与布局传播延迟**：当窗口从隐藏状态（如系统托盘）恢复并变为可见时，QML组件的尺寸和布局计算需要在组件树中逐步传播。`ActionButtons` 的父容器（侧边栏）宽度发生变化后，其子布局（如 `rootColumnLayout`）乃至孙子布局（如 `buttonRowLayout`）的宽度更新并非瞬时完成。
    *   **`buttonRowLayout.width` 初始化错误**：在托盘恢复的特定路径下，`buttonRowLayout`（它期望通过其父布局 `rootColumnLayout` 获取宽度）未能及时获得正确的宽度值。日志显示，尽管 `rootColumnLayout.width` 可能已经更新为正确的值（例如225px），`buttonRowLayout.width` 在 `reset()` 函数的早期阶段却可能仍为一个不正确的小值（例如40px）。
    *   **依赖错误宽度的计算导致按钮宽度为零**：如果 `reset()` 函数中的后续逻辑基于这个错误的、过小的 `buttonRowLayout.width` 来计算其子按钮的 `Layout.preferredWidth` 或直接设置 `width`，会导致按钮的计算宽度为0或一个极小值，从而引发重叠。
    *   **`Layout.preferredWidth` 与实际 `width` 的更新不同步**：即便在代码中正确设置了按钮的 `Layout.preferredWidth`，`RowLayout` 也需要时间来处理这个变化，并将这个首选宽度应用到其子项的实际 `width` 属性上。如果过早地读取按钮的实际 `width`（例如为了更新指示器），可能会得到旧的、不正确的宽度值。
    *   **布局循环 (`Layout polish loop detected`)**：在调试过程中，不恰当的宽度强制设置（例如，父项强制子项宽度，而子项的固有尺寸变化又试图影响父项的尺寸决策）或 `Layout.fillWidth` 属性与显式宽度设置之间的冲突，可能导致QML布局引擎进入重复的计算循环，表现为控制台出现 `Layout polish loop detected` 警告。

### 解决过程与最终方案

解决这个问题的过程涉及了多次尝试和对QML布局时序的逐步理解，最终方案结合了以下关键点：

1.  **多阶段延时处理 (`Qt.callLater` 和 `Timer`)**：在 `ActionButtons.qml` 的 `reset()` 函数中（该函数在组件变为可见或被C++代码调用时触发），引入了多个通过 `Qt.callLater` 和 `Timer` 实现的延时阶段。这确保了在读取或设置关键尺寸属性之前，给予QML布局引擎足够的时间来完成父容器尺寸的稳定和布局的传播。
    *   一个较长的初始延时（例如150ms）用于等待 `actionButtons` 及其直接子布局（`rootColumnLayout`）的宽度稳定。
    *   后续更短的延时用于在进行更细致的布局调整和指示器更新前进一步确保状态同步。

2.  **条件性宽度强制修正 `buttonRowLayout.width`**：在 `reset()` 函数的早期延时阶段（例如150ms后），增加了一个检查逻辑：如果 `buttonRowLayout.width` 相对于其父布局 `rootColumnLayout.width` 显得异常小（例如，小于父宽度的80%），则强制将 `buttonRowLayout.width` 设置为 `rootColumnLayout.width`。这个步骤主要针对从系统托盘恢复时 `buttonRowLayout.width` 未能正确初始化的异常情况。在正常启动或布局已经正确的情况下，此强制逻辑不会被触发。

3.  **依赖 `RowLayout` 的内置布局机制**：一旦 `buttonRowLayout.width` 被确保（或修正）为正确的值，后续不再手动计算或强制设置其子按钮（文件、AI、搜索按钮）的 `Layout.preferredWidth` 或 `width`。而是恢复这些按钮的 `Layout.fillWidth: true` 属性，让 `buttonRowLayout` (作为 `RowLayout`) 根据其自身的宽度和 `spacing` 属性，自动管理其子项的宽度分配。

4.  **移除冲突的布局属性**：
    *   从各个按钮（`fileButton`等）中移除了在调试过程中尝试的显式 `width` 设置，仅保留 `Layout.fillWidth: true` 和 `Layout.preferredHeight`。
    *   从 `buttonRowLayout` 中移除了 `Layout.fillWidth: true`，因为它的宽度现在由 `reset()` 函数中的逻辑（条件强制）或其父布局的约束更直接地控制。

5.  **指示器更新的时机**：确保 `_updateIndicatorGeometry()` 函数（用于更新滑动指示器的位置和大小）的调用发生在所有相关的布局（特别是按钮的实际宽度和位置）稳定之后，通常是通过在 `reset()` 函数的最后阶段使用一个短暂的 `Timer` 来触发。

6.  **日志调试**：在整个排查过程中，通过在QML代码的关键节点（如宽度读取、宽度设置、函数调用前后）添加详细的 `console.log` 语句，逐步追踪宽度值的变化、函数执行顺序和时序问题，最终定位到问题的根源。

### 总结与启示

这个案例突显了在使用QML进行复杂UI布局，尤其是在涉及动态显示/隐藏组件、窗口恢复以及多层嵌套布局时，理解和处理布局时序的重要性。QML的声明式特性和自动布局非常强大，但在某些边缘情况下，需要通过精细的延时控制和有条件的干预来确保布局的稳定性和正确性。避免不必要的显式尺寸设置，优先依赖布局元素的内置机制，并给予布局引擎充分的更新时间，是解决此类问题的关键。 